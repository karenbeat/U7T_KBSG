//Karen Beatrice Souza Gonçalves
//Projeto final para o curso de capacitação Embarcatech
//CalmBreath, assistente de respiração guiada
//Uso da matriz de LED e display LCD
#include <stdio.h>              // Biblioteca padrão para entrada e saída 
#include <string.h>             // Biblioteca para manipulação de strings e memória 
#include <stdlib.h>             // Biblioteca padrão para alocação de memória, controle de processos, etc.
#include <ctype.h>              // Biblioteca para funções de classificação e conversão de caracteres
#include "pico/stdlib.h"        // Biblioteca padrão do Raspberry Pi Pico 
#include "pico/binary_info.h"   // Biblioteca para fornecer informações binárias úteis durante a compilação
#include "inc/ssd1306.h"        // Biblioteca para controle do display OLED SSD1306
#include "hardware/i2c.h"       // Biblioteca para controle de comunicação I2C no hardware do Pico
#include "hardware/pio.h"       // Biblioteca para controle do PIO (Programmable I/O) do Pico
#include "hardware/clocks.h"    // Biblioteca para manipulação dos relógios do sistema

// Inclui o programa gerado pelo PIO, necessário para controlar os LEDs WS2818B
#include "ws2818b.pio.h"        // Código PIO para controlar LEDs WS2818B (WS2812/WS2818) via PIO

// ----------------------------------------------------------------------
// Constantes e definições
// ----------------------------------------------------------------------

// Pinos I2C para o display SSD1306
const uint I2C_SDA = 14;  // Pino de dados (SDA) para comunicação I2C
const uint I2C_SCL = 15;  // Pino de clock (SCL) para comunicação I2C

// Pino e configurações para a fita de LEDs WS2818B
#define LED_PIN     7      // Pino onde a fita de LEDs está conectada
#define LED_COUNT   25     // Número de LEDs na fita (5x5 = 25 LEDs)
#define BRIGHTNESS  0.005f // Fator de brilho (0.5% do brilho máximo)

// Definição do botão A (configurado com pull-up: quando não pressionado = 1; pressionado = 0)
#define BUTTON_A_PIN 5
#define BUTTON_B_PIN 6
// 3 sprites, cada um 5x5, em RGB = [G, R, B] (ordem que o PIO utiliza)
static uint8_t sprites[3][5][5][3] = {
    { // Sprite 1 (azul)
        { {0, 0, 0}, {0, 0, 0}, {0, 21, 255}, {0, 0, 0}, {0, 0, 0} },
        { {0, 0, 0}, {0, 0, 0}, {0, 21, 255}, {0, 0, 0}, {0, 0, 0} },
        { {0, 21, 255}, {0, 0, 0}, {0, 21, 255}, {0, 0, 0}, {0, 21, 255} },
        { {0, 0, 0}, {0, 21, 255}, {0, 21, 255}, {0, 21, 255}, {0, 0, 0} },
        { {0, 0, 0}, {0, 0, 0}, {0, 21, 255}, {0, 0, 0}, {0, 0, 0} }
    },
    { // Sprite 2 (vermelho)
        { {0, 255, 0}, {0, 255, 0}, {0, 255, 0}, {0, 255, 0}, {0, 255, 0} },
        { {0, 255, 0}, {0, 0, 0},   {0, 0, 0},   {0, 0, 0},   {0, 255, 0} },
        { {0, 255, 0}, {0, 0, 0},   {0, 0, 0},   {0, 0, 0},   {0, 255, 0} },
        { {0, 255, 0}, {0, 0, 0},   {0, 0, 0},   {0, 0, 0},   {0, 255, 0} },
        { {0, 255, 0}, {0, 255, 0}, {0, 255, 0}, {0, 255, 0}, {0, 255, 0} }
    },
    { // Sprite 3 (verde)
        { {0, 0, 0}, {0, 0, 0}, {255, 0, 24}, {0, 0, 0}, {0, 0, 0} },
        { {0, 0, 0}, {255, 0, 24}, {255, 0, 24}, {255, 0, 24}, {0, 0, 0} },
        { {255, 0, 24}, {0, 0, 0}, {255, 0, 24}, {0, 0, 0}, {255, 0, 24} },
        { {0, 0, 0}, {0, 0, 0}, {255, 0, 24}, {0, 0, 0}, {0, 0, 0} },
        { {0, 0, 0}, {0, 0, 0}, {255, 0, 24}, {0, 0, 0}, {0, 0, 0} }
    }
};

// ----------------------------------------------------------------------
// Função auxiliar para converter (x, y) em índice (0..24)
// considerando zigue-zague e invertendo a ordem (24 -> 0)
// ----------------------------------------------------------------------
int getIndex(int x, int y) {
    if (y % 2 == 0) {
        return 24 - (y * 5 + x);
    } else {
        return 24 - (y * 5 + (4 - x));
    }
}

// ----------------------------------------------------------------------
// Única função main do programa
// ----------------------------------------------------------------------
int main() {
    // Inicializa os tipos stdio padrão presentes ligados ao binário
    stdio_init_all();

    // Inicialização do i2c para o SSD1306
    i2c_init(i2c1, ssd1306_i2c_clock * 6000);
    gpio_set_function(I2C_SDA, GPIO_FUNC_I2C);
    gpio_set_function(I2C_SCL, GPIO_FUNC_I2C);
    gpio_pull_up(I2C_SDA);
    gpio_pull_up(I2C_SCL);

    // Processo de inicialização completo do OLED SSD1306
    ssd1306_init();

    // Preparar área de renderização para o display
    struct render_area frame_area = {
        .start_column = 0,
        .end_column   = ssd1306_width - 1,
        .start_page   = 0,
        .end_page     = ssd1306_n_pages - 1
    };
    calculate_render_area_buffer_length(&frame_area);

    // Zera o display inteiro
    uint8_t ssd[ssd1306_buffer_length];
    memset(ssd, 0, ssd1306_buffer_length);
    render_on_display(ssd, &frame_area);

restart:
    // Exibe a mensagem no display
    char *text[] = {
        "   ",
        "   "
    };
    int y = 0;
    for (uint i = 0; i < count_of(text); i++) {
        ssd1306_draw_string(ssd, 5, y, text[i]);
        y += 8;
    }
    render_on_display(ssd, &frame_area);

    // Exemplo de exibir linha (desativado, mas deixado como exemplo):
    /*
    ssd1306_draw_line(ssd, 10, 10, 100, 50, true);
    render_on_display(ssd, &frame_area);
    */

    // Exemplo de exibir bitmap
    const uint8_t bitmap_128x64[] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0x0f, 0xf8, 0xff, 0x1f, 0xf0, 0xff, 0xff, 0xff, 0x4f, 0xfe, 0xff, 0x9f, 0xfc, 0xff, 
	0xff, 0xff, 0xef, 0xfe, 0xff, 0xdf, 0xfd, 0xff, 0xff, 0xff, 0x0f, 0xfe, 0xff, 0x1f, 0xfc, 0xff, 
	0xff, 0xff, 0x9f, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xfe, 0xff, 
	0xff, 0xff, 0x2f, 0xfe, 0xff, 0x5f, 0xfc, 0xff, 0xff, 0xff, 0xaf, 0xfe, 0xff, 0x5f, 0xfd, 0xff, 
	0xff, 0xff, 0x0f, 0xfe, 0xff, 0x1f, 0xfc, 0xff, 0xff, 0xff, 0x3f, 0xfe, 0xff, 0x7f, 0xfc, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xfe, 0xff, 0x1f, 0xfc, 0xff, 
	0xff, 0xff, 0xef, 0xff, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff, 0xff, 0xdf, 0xff, 0xff, 
	0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xaf, 0xfe, 0xff, 0x5f, 0xfd, 0xff, 
	0x1f, 0xf0, 0xaf, 0xfe, 0xff, 0x5f, 0xfd, 0xff, 0xdf, 0xf6, 0x0f, 0xfe, 0xff, 0x1f, 0xfc, 0xff, 
	0xdf, 0xf6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xf8, 0x2f, 0xfe, 0xff, 0x5f, 0xfc, 0xff, 0x7f, 0xf5, 0xaf, 0xfe, 0xff, 0x5f, 0xfd, 0xff, 
	0x7f, 0xf5, 0xaf, 0xfe, 0xff, 0x5f, 0xfd, 0xff, 0xff, 0xf4, 0x1f, 0xfe, 0xff, 0x3f, 0xfc, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x7f, 0xf0, 0x0f, 0xfe, 0xff, 0x1f, 0xfc, 0xff, 0x7f, 0xff, 0xef, 0xff, 0xf7, 0xdf, 0xff, 0xff, 
	0x7f, 0xff, 0xef, 0xff, 0xe2, 0xdf, 0xff, 0xc5, 0x7f, 0xf0, 0x1f, 0xff, 0xea, 0x3f, 0xfe, 0xd5, 
	0xff, 0xff, 0x0f, 0xfe, 0xe0, 0x1f, 0xfc, 0xd5, 0xff, 0xff, 0xaf, 0xfe, 0xe3, 0x5f, 0xfd, 0xc3, 
	0xff, 0xff, 0x8f, 0xfe, 0xff, 0x1f, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0x01, 
	0x1f, 0xff, 0xdf, 0xfe, 0xee, 0xbf, 0xfd, 0xc9, 0x7f, 0xf8, 0xaf, 0xfe, 0xee, 0x5f, 0xfd, 0xdd, 
	0xff, 0xf3, 0x2f, 0xfe, 0xe0, 0x5f, 0xfc, 0xc1, 0x7f, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 
	0x1f, 0xff, 0x0f, 0xf8, 0xfb, 0x1f, 0xf0, 0xff, 0xff, 0xff, 0x0f, 0xf8, 0xe0, 0x1f, 0xf0, 0xc3, 
	0x5f, 0xf0, 0xef, 0xfe, 0xea, 0xdf, 0xfd, 0xd5, 0x5f, 0xf0, 0xef, 0xfe, 0xe8, 0xdf, 0xfd, 0xd5, 
	0xff, 0xff, 0x1f, 0xff, 0xf9, 0x3f, 0xfe, 0xd3, 0x7f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x7f, 0xff, 0x0b, 0xfe, 0xe0, 0x17, 0xfc, 0xc1, 0x7f, 0xff, 0x0b, 0xfe, 0xfe, 0x17, 0xfc, 0xfd, 
	0x7f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0x0f, 0xfe, 0xfe, 0x1f, 0xfc, 0xff, 
	0xff, 0xf9, 0xef, 0x7f, 0xe0, 0xdf, 0xff, 0xe0, 0x7f, 0xf0, 0xef, 0xff, 0xee, 0xdf, 0xff, 0xc0, 
	0x7f, 0xf7, 0x7f, 0xff, 0xff, 0xff, 0xfe, 0xdd, 0x7f, 0xf7, 0x2f, 0xfe, 0xf1, 0x5f, 0xfc, 0xe3, 
	0x1f, 0xf0, 0xaf, 0xfe, 0xea, 0x5f, 0xfd, 0xc1, 0xff, 0xff, 0x0f, 0xfe, 0xea, 0x1f, 0xfc, 0xd5, 
	0xff, 0xf8, 0xff, 0xff, 0xe8, 0xff, 0xff, 0xd1, 0x7f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 
	0x7f, 0xf7, 0x0f, 0xfe, 0xff, 0x1f, 0xfc, 0xff, 0x7f, 0xf7, 0xef, 0xfa, 0xff, 0xdf, 0xf5, 0xff, 
	0xff, 0xf8, 0xef, 0xf8, 0xef, 0xdf, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xff, 0x7f, 0xc0, 
	0x7f, 0xf8, 0x2f, 0x3e, 0xf8, 0x5f, 0x7c, 0xc0, 0x1f, 0xe3, 0xad, 0x3e, 0xfb, 0x5b, 0x7d, 0xdb, 
	0xdf, 0xef, 0xab, 0x7e, 0xf8, 0x57, 0x7d, 0xc0, 0xff, 0xfb, 0x1d, 0xfe, 0xe3, 0x3b, 0xfc, 0xe7, 
	0x7f, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xf5, 0x1f, 0xff, 0xff, 0x3f, 0xfe, 0xff, 
	0x7f, 0xf0, 0xef, 0xfe, 0xff, 0xdf, 0xfd, 0xff, 0xff, 0xff, 0xef, 0xfe, 0xff, 0xdf, 0xfd, 0xff, 
	0xdf, 0xef, 0x0f, 0xfe, 0xff, 0x1f, 0xfc, 0xff, 0x1f, 0xe0, 0x1f, 0xff, 0xff, 0x3f, 0xfe, 0xff, 
	0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x1f, 0xf4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xf4, 0x3f, 0xff, 0xff, 0x7f, 0xfe, 0xff, 
	0xff, 0xff, 0x1f, 0xff, 0xff, 0x3f, 0xfe, 0xff, 0x1f, 0xf4, 0x67, 0xff, 0xff, 0xcf, 0xfe, 0xff, 
	0x1f, 0xf4, 0x03, 0xfe, 0xff, 0x07, 0xfc, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xfe, 0xff, 
	0x1f, 0xf4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xf4, 0xbf, 0xff, 0xff, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xbf, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xfb, 0xfe, 0xff, 0x3f, 0xfe, 0xff, 
	0xff, 0xff, 0x1b, 0xfe, 0xff, 0xcf, 0xfe, 0xff, 0xff, 0xff, 0xe3, 0xff, 0xff, 0x07, 0xfc, 0xff, 
	0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xbf, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 
	0xff, 0xff, 0xfb, 0xff, 0xff, 0x3f, 0xfe, 0xff, 0xff, 0xff, 0x1b, 0xfe, 0xff, 0xcf, 0xfe, 0xff, 
	0xff, 0xff, 0xc3, 0xff, 0xff, 0x07, 0xfc, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xfe, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    };

    ssd1306_t ssd_bm;
    ssd1306_init_bm(&ssd_bm, 128, 64, false, 0x3C, i2c1);
    ssd1306_config(&ssd_bm);
    ssd1306_draw_bitmap(&ssd_bm, bitmap_128x64);


    gpio_init(BUTTON_A_PIN);  // Inicializa o pino do botão A
    gpio_set_dir(BUTTON_A_PIN, GPIO_IN);  // Define o pino do botão A como entrada
    gpio_pull_up(BUTTON_A_PIN);  // Habilita o resistor de pull-up no botão A

    // Configuração do botão B
    gpio_init(BUTTON_B_PIN);  // Inicializa o pino do botão B
    gpio_set_dir(BUTTON_B_PIN, GPIO_IN);  // Define o pino do botão B como entrada
    gpio_pull_up(BUTTON_B_PIN);  // Habilita o resistor de pull-up no botão B


    // Configuração do PIO para controlar a fita de LEDs WS2818B
    PIO pio = pio0;
    int sm = pio_claim_unused_sm(pio, true);
    uint offset = pio_add_program(pio, &ws2818b_program);
    ws2818b_program_init(pio, sm, offset, LED_PIN, 800000.0f);

    // Apaga a fita duas vezes para evitar lixo inicial
    for (int repeat = 0; repeat < 2; repeat++) {
        for (int i = 0; i < LED_COUNT; i++) {
            pio_sm_put_blocking(pio, sm, 0); // G
            pio_sm_put_blocking(pio, sm, 0); // R
            pio_sm_put_blocking(pio, sm, 0); // B
        }
        sleep_us(100);
        sleep_ms(50);
    }

    while (true) {
        //----------------------------------------------------------------------
        // 1) SE O BOTÃO A FOR PRESSIONADO
        //----------------------------------------------------------------------
        if (gpio_get(BUTTON_A_PIN) == 0) { // Checa se está apertado (nível baixo se for pull-up)
            sleep_ms(50);  // Debounce
            // Verifica se ainda está pressionado após o debounce
            if (gpio_get(BUTTON_A_PIN) == 0) {
                // ---------------------------
                // Executa os 3 ciclos (A)
                // ---------------------------
                for (int ciclo = 0; ciclo < 3; ciclo++) {
                    for (int s = 0; s < 3; s++) {
                        // Envia os 25 pixels do sprite 's'
                        for (int y = 0; y < 5; y++) {
                            for (int x = 0; x < 5; x++) {
                                int pos = getIndex(x, y);  // Cálculo de índice (se necessário)
                                uint8_t G = (uint8_t)(sprites[s][y][x][0] * BRIGHTNESS);
                                uint8_t R = (uint8_t)(sprites[s][y][x][1] * BRIGHTNESS);
                                uint8_t B = (uint8_t)(sprites[s][y][x][2] * BRIGHTNESS);

                                pio_sm_put_blocking(pio, sm, G);
                                pio_sm_put_blocking(pio, sm, R);
                                pio_sm_put_blocking(pio, sm, B);
                            }
                        }
                        // Pausa para o latch do WS2812/WS2818
                        sleep_us(100);

                        // Tempo de exibição:
                        // - Sprite 1 (s == 0): 4 segundos
                        // - Sprites 2 e 3 (s == 1 ou 2): 7 segundos
                        if (s == 0) {
                            sleep_ms(4000);
                        } else {
                            sleep_ms(7000);
                        }

                        // Apaga a fita (envia zeros para todos os LEDs)
                        for (int i = 0; i < LED_COUNT; i++) {
                            pio_sm_put_blocking(pio, sm, 0);
                            pio_sm_put_blocking(pio, sm, 0);
                            pio_sm_put_blocking(pio, sm, 0);
                        }
                        sleep_us(100);
                        sleep_ms(50);
                    }
                }

                // Ao final dos 3 ciclos, apaga definitivamente
                for (int i = 0; i < LED_COUNT; i++) {
                    pio_sm_put_blocking(pio, sm, 0);
                    pio_sm_put_blocking(pio, sm, 0);
                    pio_sm_put_blocking(pio, sm, 0);
                }
                sleep_us(100);
                sleep_ms(50);

                // ---------------------------
                // Enquanto o A CONTINUAR apertado, não faz nada
                // ---------------------------
                while (gpio_get(BUTTON_A_PIN) == 0) {
                    sleep_ms(10);
                }
            }
        }

        //----------------------------------------------------------------------
        // 2) SE O BOTÃO B FOR PRESSIONADO
        //----------------------------------------------------------------------
        if (gpio_get(BUTTON_B_PIN) == 0) { 
            sleep_ms(50);  // Debounce
            // Verifica se ainda está pressionado
            if (gpio_get(BUTTON_B_PIN) == 0) {
                // ---------------------------
                // Executa os 4 ciclos (B)
                // ---------------------------
                for (int ciclo = 0; ciclo < 4; ciclo++) {
                    for (int s = 0; s < 3; s++) {
                        // Envia os 25 pixels do sprite 's'
                        for (int y = 0; y < 5; y++) {
                            for (int x = 0; x < 5; x++) {
                                int pos = getIndex(x, y);
                                uint8_t G = (uint8_t)(sprites[s][y][x][0] * BRIGHTNESS);
                                uint8_t R = (uint8_t)(sprites[s][y][x][1] * BRIGHTNESS);
                                uint8_t B = (uint8_t)(sprites[s][y][x][2] * BRIGHTNESS);

                                pio_sm_put_blocking(pio, sm, G);
                                pio_sm_put_blocking(pio, sm, R);
                                pio_sm_put_blocking(pio, sm, B);
                            }
                        }
                        sleep_us(100);
                        
                        // Tempo de exibição (4s cada sprite)
                        sleep_ms(4000);

                        // Apaga a fita
                        for (int i = 0; i < LED_COUNT; i++) {
                            pio_sm_put_blocking(pio, sm, 0);
                            pio_sm_put_blocking(pio, sm, 0);
                            pio_sm_put_blocking(pio, sm, 0);
                        }
                        sleep_us(100);
                        sleep_ms(50);
                    }
                }

                // Ao final dos 4 ciclos, apaga definitivamente
                for (int i = 0; i < LED_COUNT; i++) {
                    pio_sm_put_blocking(pio, sm, 0);
                    pio_sm_put_blocking(pio, sm, 0);
                    pio_sm_put_blocking(pio, sm, 0);
                }
                sleep_us(100);
                sleep_ms(50);

                // ---------------------------
                // Enquanto o B CONTINUAR apertado, não faz nada
                // ---------------------------
                while (gpio_get(BUTTON_B_PIN) == 0) {
                    sleep_ms(10);
                }
            }
        }

        // Pequena pausa 
        sleep_ms(10);
    }

    return 0;  // Fim do programa
}
