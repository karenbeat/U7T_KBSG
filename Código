/*
Karen Beatrice Souza Gonçalves
 * Projeto final do curso EmbarcaTech para Raspberry Pi Pico que utiliza:
 * - Um display OLED SSD1306 via I2C.
 * - Uma matriz de LEDs WS2818B controlada via PIO.
 * - Um botão (BUTTON A) para acionar a sequência de exibição dos sprites.
 *
 * O código realiza as seguintes funções:
 * 1. Inicializa o display OLED, desenhando uma mensagem de boas-vindas e a nstrução de apertar o botão.
 * 2. Configura a matriz de LEDs WS2818B e a apaga inicialmente para iniciar uma sessão de respiração guiada
 * 3. Aguarda a pressão do botão para exibir, em 3 ciclos, 3 sprites diferentes (azul, verde e vermelho)
 *    em uma matriz 5x5 de LEDs, aplicando um fator de brilho.
 *
 * Cada sprite é definido como uma matriz 5x5 com pixels no formato [G, R, B], 
 * obedecendo à ordem exigida pelo protocolo WS2818B.
 *
 * A função getIndex() converte coordenadas (x, y) para um índice linear (0 a 24) levando
 * em conta um padrão zigue-zague (zigzag) com a numeração invertida.
 */

 #include <stdio.h>
 #include "pico/stdlib.h"             // Biblioteca padrão do Pico (GPIO, temporizações, etc.)
 #include "hardware/pio.h"            // Funções para utilização do PIO (Programmable I/O)
 #include "hardware/clocks.h"         // Funções relacionadas aos clocks (timing, frequências, etc.)
 #include <string.h>                  // Funções para manipulação de strings e memória (memset, etc.)
 #include <stdlib.h>                  // Funções utilitárias padrão
 #include <ctype.h>                   // Funções de manipulação de caracteres
 #include "pico/binary_info.h"        // Macros e funções para informações binárias
 #include "inc/ssd1306.h"             // Driver do display OLED SSD1306
 #include "hardware/i2c.h"            // Funções para comunicação via I2C
 
 /* ----------------------------------------------------------------------
  * Constantes e definições
  * ---------------------------------------------------------------------- */
 
 // Define os pinos para a comunicação I2C com o display SSD1306
 const uint I2C_SDA = 14;             // Pino utilizado para o sinal SDA (dados)
 const uint I2C_SCL = 15;             // Pino utilizado para o sinal SCL (clock)
 
 // Inclui o código do PIO para controlar a fita de LEDs WS2818B
 #include "ws2818b.pio.h"
 
 // Configurações para a fita de LEDs WS2818B
 #define LED_PIN     7              // Pino conectado à fita de LEDs WS2818B
 #define LED_COUNT   25             // Número total de LEDs na fita (5x5 = 25 LEDs)
 #define BRIGHTNESS  0.005f         // Fator de brilho aplicado aos LEDs (0.5% do valor original)
 
 // Configuração do botão A (com pull-up: quando não pressionado = 1, pressionado = 0)
 #define BUTTON_A_PIN 5
 
 /*
  * Definição dos sprites: três imagens de 5x5 pixels.
  * Cada sprite é representado como uma matriz 5x5 onde cada elemento possui 3 componentes de cor.
  * A ordem das cores é [G, R, B], que corresponde à ordem exigida pelo protocolo WS2818B.
  *
  * Sprite 1: Azul
  * Sprite 2: Vermelho
  * Sprite 3: Verde
  */
 static uint8_t sprites[3][5][5][3] = {
     { // Sprite 1 (azul)
         { {0, 0, 0}, {0, 0, 0}, {0, 21, 255}, {0, 0, 0}, {0, 0, 0} },
         { {0, 0, 0}, {0, 0, 0}, {0, 21, 255}, {0, 0, 0}, {0, 0, 0} },
         { {0, 21, 255}, {0, 0, 0}, {0, 21, 255}, {0, 0, 0}, {0, 21, 255} },
         { {0, 0, 0}, {0, 21, 255}, {0, 21, 255}, {0, 21, 255}, {0, 0, 0} },
         { {0, 0, 0}, {0, 0, 0}, {0, 21, 255}, {0, 0, 0}, {0, 0, 0} }
     },
     { // Sprite 2 (vermelho)
         { {0, 255, 0}, {0, 255, 0}, {0, 255, 0}, {0, 255, 0}, {0, 255, 0} },
         { {0, 255, 0}, {0, 0, 0},   {0, 0, 0},   {0, 0, 0},   {0, 255, 0} },
         { {0, 255, 0}, {0, 0, 0},   {0, 0, 0},   {0, 0, 0},   {0, 255, 0} },
         { {0, 255, 0}, {0, 0, 0},   {0, 0, 0},   {0, 0, 0},   {0, 255, 0} },
         { {0, 255, 0}, {0, 255, 0}, {0, 255, 0}, {0, 255, 0}, {0, 255, 0} }
     },
     { // Sprite 3 (verde)
         { {0, 0, 0}, {0, 0, 0}, {255, 0, 24}, {0, 0, 0}, {0, 0, 0} },
         { {0, 0, 0}, {255, 0, 24}, {255, 0, 24}, {255, 0, 24}, {0, 0, 0} },
         { {255, 0, 24}, {0, 0, 0}, {255, 0, 24}, {0, 0, 0}, {255, 0, 24} },
         { {0, 0, 0}, {0, 0, 0}, {255, 0, 24}, {0, 0, 0}, {0, 0, 0} },
         { {0, 0, 0}, {0, 0, 0}, {255, 0, 24}, {0, 0, 0}, {0, 0, 0} }
     }
 };
 
 /*
  * Função auxiliar para converter coordenadas (x, y) de uma matriz 5x5 para um índice linear (0..24)
  * considerando que os LEDs estão organizados em um padrão zigue-zague (zigzag) e invertendo a ordem (24 -> 0).
  *
  * O padrão zigue-zague significa que a ordem dos LEDs alterna a cada linha:
  * - Em linhas pares (y % 2 == 0), os LEDs são indexados da esquerda para a direita.
  * - Em linhas ímpares, os LEDs são indexados da direita para a esquerda.
  *
  * A inversão (24 - valor) garante que a numeração dos LEDs inicie do final (LED 24) até o início (LED 0).
  */
 int getIndex(int x, int y) {
     if (y % 2 == 0) {
         // Linha par: indexação normal (esquerda para direita)
         return 24 - (y * 5 + x);
     } else {
         // Linha ímpar: inverte a ordem dos pixels na linha (direita para esquerda)
         return 24 - (y * 5 + (4 - x));
     }
 }
 
 /*
  * Função principal do programa.
  * Realiza a inicialização dos periféricos, configura o display OLED, configura o PIO para os LEDs,
  * e executa o loop principal que aguarda a pressão do botão para exibir os sprites.
  */
 int main() {
     // Inicializa a biblioteca padrão, permitindo o uso de GPIO, UART, etc.
     stdio_init_all();
 
     // Inicializa o I2C para o display SSD1306.
     // A velocidade do I2C é definida com base em ssd1306_i2c_clock * 6000.
     i2c_init(i2c1, ssd1306_i2c_clock * 6000);
     // Configura os pinos I2C para a função I2C.
     gpio_set_function(I2C_SDA, GPIO_FUNC_I2C);
     gpio_set_function(I2C_SCL, GPIO_FUNC_I2C);
     // Ativa os resistores de pull-up nos pinos I2C.
     gpio_pull_up(I2C_SDA);
     gpio_pull_up(I2C_SCL);
 
     // Inicializa o display SSD1306.
     ssd1306_init();
 
     // Configura a área de renderização do display, utilizando a área completa.
     struct render_area frame_area = {
         .start_column = 0,
         .end_column   = ssd1306_width - 1,
         .start_page   = 0,
         .end_page     = ssd1306_n_pages - 1
     };
     // Calcula o tamanho do buffer necessário para renderizar a área definida.
     calculate_render_area_buffer_length(&frame_area);
 
     // Cria um buffer para a renderização e o zera (preenchido com 0s).
     uint8_t ssd[ssd1306_buffer_length];
     memset(ssd, 0, ssd1306_buffer_length);
     // Renderiza o buffer (tela em branco) no display.
     render_on_display(ssd, &frame_area);
 
 restart:
     // Exibe uma mensagem de boas-vindas no display.
     // As mensagens são definidas em um array de strings.
     char *text[] = {
         "    ",
         "     "
     };
     int y = 0; // Posição vertical inicial para o texto.
     // Percorre cada linha do array e desenha a string no buffer, com um deslocamento vertical.
     for (uint i = 0; i < count_of(text); i++) {
         ssd1306_draw_string(ssd, 5, y, text[i]);
         y += 8; // Incrementa 8 pixels para a próxima linha (altura da fonte)
     }
     // Atualiza o display com o conteúdo do buffer.
     render_on_display(ssd, &frame_area);
 
     // Exemplo de desenho de linha (comentado, serve apenas como referência):
     /*
     ssd1306_draw_line(ssd, 10, 10, 100, 50, true);
     render_on_display(ssd, &frame_area);
     */
 
     // Exibe bitmap no display.
     // Define um array de bytes representando uma imagem de 128x64 pixels.
     const uint8_t bitmap_128x64[] = {
         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
         0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x82, 0xff, 0xff, 0xff, 
         0xff, 0xff, 0xff, 0x7f, 0x92, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x9a, 0xff, 0xff, 0xff, 
         0xff, 0xff, 0xff, 0x7f, 0xca, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x80, 0xff, 0xff, 0xff, 
         0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 
         0xff, 0x01, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x99, 0xf3, 0x7f, 0x00, 0xfc, 0xff, 0xff, 
         0xff, 0x99, 0xf3, 0x7f, 0x00, 0xfc, 0xff, 0xff, 0xff, 0x99, 0xf3, 0xff, 0xde, 0xff, 0xff, 0xff, 
         0xff, 0x01, 0xf1, 0x7f, 0x9e, 0xff, 0xff, 0xff, 0xff, 0x23, 0xf8, 0x7f, 0x9e, 0xff, 0x07, 0xc0, 
         0xff, 0x77, 0xf8, 0x7f, 0x80, 0xff, 0x07, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xef, 0xfd, 
         0xff, 0x3f, 0xfc, 0xff, 0xff, 0xff, 0xe7, 0xf9, 0xff, 0x1f, 0xf8, 0xff, 0xe1, 0xff, 0xe7, 0xf9, 
         0xff, 0x4f, 0xf1, 0xff, 0xc0, 0xff, 0x07, 0xf8, 0xff, 0x4f, 0xf3, 0x7f, 0x80, 0xff, 0x0f, 0xfc, 
         0xff, 0x4f, 0xf3, 0x7f, 0x9a, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xf3, 0x7f, 0x9a, 0xff, 0x7f, 0xfc, 
         0xff, 0x1f, 0xff, 0x7f, 0x98, 0xff, 0x27, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xc8, 0xff, 0x27, 0xf9, 
         0xff, 0x0f, 0xf0, 0xff, 0xff, 0xff, 0xa7, 0xf9, 0xff, 0x0f, 0xf0, 0xff, 0xff, 0xff, 0xa7, 0xfc, 
         0xff, 0x0f, 0xf0, 0x7f, 0x80, 0xff, 0x07, 0xf8, 0xff, 0xdf, 0xff, 0x7f, 0x80, 0xff, 0x1f, 0xf8, 
         0xff, 0xcf, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xf0, 0x7f, 0xfe, 0xff, 0xff, 0xff, 
         0xff, 0x1f, 0xf0, 0xff, 0xff, 0xff, 0x07, 0xf8, 0xff, 0x9f, 0xff, 0x7f, 0xfe, 0xff, 0x07, 0xf8, 
         0xff, 0xcf, 0xff, 0x3f, 0xc0, 0xff, 0xef, 0xff, 0xff, 0xcf, 0xff, 0x1f, 0x80, 0xff, 0xe7, 0xff, 
         0xff, 0x0f, 0xf0, 0x1f, 0x80, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xf0, 0x7f, 0x9e, 0xff, 0x6f, 0xfc, 
         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x27, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 0x27, 0xf9, 
         0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xa7, 0xfd, 0xff, 0xff, 0xff, 0x7f, 0x8a, 0xff, 0x07, 0xf8, 
         0xff, 0xff, 0xff, 0x7f, 0x9a, 0xff, 0x0f, 0xf8, 0xff, 0xf9, 0xff, 0x7f, 0x9a, 0xff, 0x1f, 0xf8, 
         0xff, 0xc1, 0xff, 0x7f, 0x98, 0xff, 0xff, 0xff, 0xff, 0x03, 0xfe, 0xff, 0xf8, 0xff, 0xff, 0xff, 
         0xff, 0x1f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 
         0xff, 0x7f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xfc, 0xff, 0xff, 0xff, 0x1f, 0xfe, 
         0xff, 0x81, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xfc, 0xff, 0xf1, 0xff, 0xff, 0xe1, 0xff, 0xc7, 0xf8, 
         0xff, 0xfd, 0xff, 0xff, 0xc0, 0xff, 0xe7, 0xf9, 0xff, 0xff, 0xff, 0x7f, 0x8c, 0xff, 0xe7, 0xf9, 
         0xff, 0x09, 0xf0, 0x7f, 0x9e, 0xff, 0xe7, 0xf9, 0xff, 0x09, 0xf0, 0x7f, 0x9e, 0xff, 0xff, 0xff, 
         0xff, 0xff, 0xff, 0x7f, 0x8c, 0xff, 0x1f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0x0f, 0xfc, 
         0xff, 0x0f, 0xf0, 0xff, 0xe1, 0xff, 0xc7, 0xf8, 0xff, 0x0f, 0xf0, 0xff, 0xff, 0xff, 0xe7, 0xf9, 
         0xff, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xf9, 0xff, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xf8, 
         0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xfc, 0xff, 0x0f, 0xf0, 0xff, 0xff, 0xff, 0x1f, 0xfe, 
         0xff, 0x1f, 0xf0, 0x0f, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x80, 0xff, 0x07, 0xf8, 
         0xff, 0x3f, 0xfc, 0x0f, 0x80, 0xff, 0x07, 0xf8, 0xff, 0x1f, 0xf8, 0xff, 0x9e, 0xff, 0x07, 0xf8, 
         0xff, 0x8f, 0xf1, 0x7f, 0x9e, 0xff, 0xef, 0xff, 0xff, 0xcf, 0xf3, 0x7f, 0x8c, 0xff, 0xe7, 0xff, 
         0xff, 0xcf, 0xf3, 0x7f, 0xc0, 0xff, 0x07, 0xf8, 0xff, 0x9f, 0xf9, 0xff, 0xe0, 0xff, 0x0f, 0xf8, 
         0xff, 0x01, 0xf0, 0xff, 0xff, 0xff, 0xcf, 0xff, 0xff, 0x01, 0xf0, 0xff, 0xe1, 0xff, 0xe7, 0xff, 
         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
         0xff, 0xf9, 0xf3, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xff, 0x01, 0xf2, 0xff, 0x87, 0xff, 0xff, 0xff, 
         0xff, 0x81, 0xf3, 0xff, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xe0, 0xff, 0xff, 0xff, 
         0xff, 0xff, 0xff, 0x0f, 0xe6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8f, 0xe7, 0xff, 0xff, 0xff, 
         0xff, 0xff, 0xff, 0x0f, 0xe4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xe0, 0xff, 0xff, 0xff, 
         0xff, 0xff, 0xff, 0xff, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 
         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
     };
 
     // Inicializa uma instância do display SSD1306 para exibir o bitmap.
     ssd1306_t ssd_bm;
     ssd1306_init_bm(&ssd_bm, 128, 64, false, 0x3C, i2c1);
     // Configura o display.
     ssd1306_config(&ssd_bm);
     // Desenha o bitmap definido no display.
     ssd1306_draw_bitmap(&ssd_bm, bitmap_128x64);
 
     // Configuração do botão A: inicializa, define como entrada e ativa o pull-up.
     gpio_init(BUTTON_A_PIN);
     gpio_set_dir(BUTTON_A_PIN, GPIO_IN);
     gpio_pull_up(BUTTON_A_PIN);
 
     // Configuração do PIO para controlar a fita de LEDs WS2818B.
     // Utiliza o PIO 0 e aloca um state machine livre.
     PIO pio = pio0;
     int sm = pio_claim_unused_sm(pio, true);
     // Carrega o programa PIO (ws2818b_program) e obtém o offset na memória do PIO.
     uint offset = pio_add_program(pio, &ws2818b_program);
     // Inicializa o programa PIO para WS2818B, configurando o pino e a frequência de 800 kHz.
     ws2818b_program_init(pio, sm, offset, LED_PIN, 800000.0f);
 
     // Apaga a fita de LEDs duas vezes para garantir que nenhum dado residual seja exibido.
     for (int repeat = 0; repeat < 2; repeat++) {
         for (int i = 0; i < LED_COUNT; i++) {
             // Envia valor 0 para cada componente de cor (G, R, B) de cada LED.
             pio_sm_put_blocking(pio, sm, 0); // G
             pio_sm_put_blocking(pio, sm, 0); // R
             pio_sm_put_blocking(pio, sm, 0); // B
         }
         // Pequena pausa para que os LEDs processem o comando.
         sleep_us(100);
         sleep_ms(50);
     }
 
     /*
      * Loop principal:
      * - Aguarda a pressão do botão A.
      * - Quando pressionado, executa 3 ciclos de exibição dos sprites.
      * - Cada ciclo exibe os 3 sprites (com tempos de exibição específicos para cada um).
      * - Após os 3 ciclos, os LEDs são apagados e o programa aguarda a liberação do botão
      *   para reiniciar a sequência.
      */
     while (true) {
         // Aguarda até que o botão A seja pressionado (valor 0 indica botão pressionado).
         while (gpio_get(BUTTON_A_PIN) != 0) {
             sleep_ms(10);
         }
         // Debounce: aguarda 50 ms para evitar múltiplas leituras devido a ruídos.
         sleep_ms(50);
 
         // Executa 3 ciclos de exibição dos sprites.
         for (int ciclo = 0; ciclo < 3; ciclo++) {
             // Para cada um dos 3 sprites (índices 0, 1 e 2)
             for (int s = 0; s < 3; s++) {
                 // Percorre cada linha (yy) e coluna (xx) do sprite 5x5
                 for (int yy = 0; yy < 5; yy++) {
                     for (int xx = 0; xx < 5; xx++) {
                         // Calcula o índice do LED correspondente na fita (padrão zigue-zague)
                         int pos = getIndex(xx, yy);
 
                         // Aplica o fator de brilho em cada componente (G, R, B)
                         uint8_t G = (uint8_t)(sprites[s][yy][xx][0] * BRIGHTNESS);
                         uint8_t R = (uint8_t)(sprites[s][yy][xx][1] * BRIGHTNESS);
                         uint8_t B = (uint8_t)(sprites[s][yy][xx][2] * BRIGHTNESS);
 
                         // Envia os valores de cor para o LED na ordem: G, R, B
                         pio_sm_put_blocking(pio, sm, G);
                         pio_sm_put_blocking(pio, sm, R);
                         pio_sm_put_blocking(pio, sm, B);
                     }
                 }
                 // Pausa curta para garantir o latch (fixação dos dados) no WS2818B.
                 sleep_us(100);
 
                 // Define o tempo de exibição para cada sprite:
                 // - Sprite 1 (índice 0): 4 segundos.
                 // - Sprites 2 e 3 (índices 1 e 2): 7 segundos.
                 if (s == 0) {
                     sleep_ms(4000);
                 } else {
                     sleep_ms(7000);
                 }
 
                 // Após o tempo de exibição, apaga a fita de LEDs enviando zeros.
                 for (int i = 0; i < LED_COUNT; i++) {
                     pio_sm_put_blocking(pio, sm, 0);
                     pio_sm_put_blocking(pio, sm, 0);
                     pio_sm_put_blocking(pio, sm, 0);
                 }
                 sleep_us(100);
                 sleep_ms(50);
             }
         }
 
         // Ao final dos 3 ciclos, apaga definitivamente os LEDs.
         for (int i = 0; i < LED_COUNT; i++) {
             pio_sm_put_blocking(pio, sm, 0);
             pio_sm_put_blocking(pio, sm, 0);
             pio_sm_put_blocking(pio, sm, 0);
         }
         sleep_us(100);
         sleep_ms(50);
 
         // Aguarda a liberação do botão para que a sequência seja reiniciada apenas com nova pressão.
         while (gpio_get(BUTTON_A_PIN) == 0) {
             sleep_ms(10);
         }
     }
 
     return 0; // Retorno padrão (nunca alcançado, pois o loop é infinito)
 }
 
